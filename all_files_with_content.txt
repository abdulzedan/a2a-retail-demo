=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/requirements.txt ===
# Core Python dependencies
python-dotenv==1.1.0
pydantic==2.11.3
pydantic-settings==2.5.2

# Official A2A SDK and samples
git+https://github.com/google/a2a-python.git
google-adk>=1.0.0

# Web framework
fastapi==0.115.12
uvicorn==0.34.2
httpx==0.28.1
python-multipart==0.0.9
aiofiles==24.1.0

# Google GenAI
google-genai>=1.14.0

# LangChain / LangGraph for customer service agent
langchain==0.3.25
langchain-core==0.3.61
langchain-google-genai==2.1.4
langgraph==0.4.5

# UI & misc
mesop==1.0.1
requests==2.32.3
structlog==24.4.0
rich==13.9.2

# Testing
pytest==8.3.3
pytest-asyncio==0.24.0
pytest-cov==5.0.0

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/.env.sample ===


=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/.pre-commit-config.yaml ===
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: check-yaml
      - id: end-of-file-fixer
      - id: trailing-whitespace
  
  - repo: https://github.com/psf/black
    rev: 25.1.0
    hooks:
      - id: black
        args:
          - --config=pyproject.toml
        files: ^backend/.*\.py$
  
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.11.8
    hooks:
      - id: ruff
        args: ["--fix", "--config", "pyproject.toml"]
        # Force run on all files every time
        always_run: true
        pass_filenames: false

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/Makefile ===
# A2A Retail Demo Makefile
.PHONY: help setup install clean test check start stop dev

# Default target
help:
	@echo "🚀 A2A Retail Demo - Available Commands"
	@echo "======================================"
	@echo "setup     - Set up development environment"
	@echo "install   - Install dependencies"  
	@echo "check     - Check system requirements and configuration"
	@echo "test      - Run tests"
	@echo "clean     - Clean up generated files"
	@echo "start     - Start all A2A agents and frontend"
	@echo "stop      - Stop all running services"
	@echo "help      - Show this help message"

# Set up development environment
setup:
	@echo "🛠️  Setting up development environment..."
	python3 -m venv .venv || python -m venv .venv
	@echo "📦 Installing dependencies..."
	.venv/bin/pip install --upgrade pip
	.venv/bin/pip install -r requirements.txt
	@echo "✅ Setup complete! Don't forget to:"
	@echo "   1. Copy .env.example to .env"
	@echo "   2. Set your GOOGLE_API_KEY in .env"

# Install dependencies only
install:
	@echo "📦 Installing dependencies..."
	.venv/bin/pip install --upgrade pip
	.venv/bin/pip install -r requirements.txt

# Start all services
start:
	@echo "🚀 Starting A2A Retail Demo..."
	chmod +x scripts/start_a2a_demo.sh
	./scripts/start_a2a_demo.sh

# Stop all services  
stop:
	@echo "🛑 Stopping all services..."
	-pkill -f "inventory_agent_a2a"
	-pkill -f "customer_service_a2a"
	-pkill -f "frontend/app.py"
	@echo "✅ All services stopped"

# Clean up
clean:
	@echo "🧹 Cleaning up..."
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	find . -name "*.pyc" -delete 2>/dev/null || true
	@echo "✅ Cleanup complete"

# Development mode (same as start)
dev: start

# Check system
check:
	@echo "🔍 Checking system requirements..."
	@python --version
	@echo "📦 Checking dependencies..."
	@.venv/bin/pip list | grep -E "(google-adk|langchain|mesop|a2a)" || echo "⚠️  Some dependencies missing"

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/pyproject.toml ===
[tool.black]
line-length = 88
target-version = ['py311']
include = '\\.pyi?$'
extend-exclude = '''
/(
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | _build
  | buck-out
  | build
  | dist
)/
'''

[tool.ruff]
line-length = 88
target-version = "py311"
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = [
    "E501",  # line too long, handled by black
    "B008",  # do not perform function calls in argument defaults
    "C901",  # too complex
]

[tool.ruff.per-file-ignores]
"__init__.py" = ["F401"]

[tool.ruff.isort]
known-third-party = ["google", "langchain", "mesop", "pydantic"]

[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q --strict-markers --ignore=frontend/"
testpaths = [
    "backend/tests",
]
python_files = "test_*.py"
python_classes = "Test*"
python_functions = "test_*"

[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools.packages.find]
where = ['.']
include = ['backend', 'backend.*', 'frontend', 'frontend.*']
exclude = ['logs', 'data']

[project]
name = "a2a-retail-demo"
version = "0.1.0"
description = "A demonstration of Google's A2A protocol with ADK and LangGraph agents"
readme = "README.md"
requires-python = ">=3.11"
license = { text = "Apache-2.0" }
authors = [
    { name = "A2A Demo Team", email = "demo@example.com" },
]
keywords = ["a2a", "agents", "ai", "llm", "gemini", "adk", "langgraph"]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Apache Software License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

[project.urls]
Homepage = "https://github.com/example/a2a-retail-demo"
Documentation = "https://github.com/example/a2a-retail-demo/blob/main/README.md"
Repository = "https://github.com/example/a2a-retail-demo"
Issues = "https://github.com/example/a2a-retail-demo/issues"


=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/dump_project.py ===
import os

root_dir = os.path.abspath(os.path.dirname(__file__))
output_file = os.path.join(root_dir, "all_files_with_content.txt")

# Read .gitignore patterns (simple: only supports lines ending with / or filenames)
ignore_patterns = set()
gitignore_path = os.path.join(root_dir, ".gitignore")
if os.path.exists(gitignore_path):
    with open(gitignore_path, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            ignore_patterns.add(line)

# Always ignore .venv and the output file
ignore_patterns.update({".venv", "all_files_with_content.txt", ".git", "__pycache__"})

def should_ignore(rel_path):
    for pattern in ignore_patterns:
        # Ignore directories
        if pattern.endswith("/") and rel_path.startswith(pattern.rstrip("/")):
            return True
        # Ignore files by name
        if os.path.basename(rel_path) == pattern:
            return True
        # Ignore files by relative path
        if rel_path == pattern:
            return True
    return False

with open(output_file, "w", encoding="utf-8") as out:
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Remove ignored directories in-place
        dirnames[:] = [d for d in dirnames if not should_ignore(os.path.relpath(os.path.join(dirpath, d), root_dir))]
        for filename in filenames:
            rel_path = os.path.relpath(os.path.join(dirpath, filename), root_dir)
            if should_ignore(rel_path):
                continue
            file_path = os.path.join(dirpath, filename)
            out.write(f"=== {os.path.abspath(file_path)} ===\n")
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    out.write(f.read())
            except Exception as e:
                out.write(f"[Could not read file: {e}]\n")
            out.write("\n\n")
print(f"Done! Output written to {output_file}")

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/README.md ===


=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/requirements-dev.txt ===
ruff
black
pre-commit
pytest
pytest-cov
python-dotenv

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/.gitignore ===
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
Pipfile.lock

# PEP 582
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Project specific
*.db
*.sqlite
logs/
temp/
data/

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/.env.example ===
# Google AI / Gemini Configuration
GOOGLE_API_KEY=your-google-api-key-here

# Google Cloud Configuration (if using Vertex AI)
GOOGLE_CLOUD_PROJECT=your-project-id
GOOGLE_CLOUD_LOCATION=us-central1
GOOGLE_GENAI_USE_VERTEXAI=False

# Agent URLs
HOST_AGENT_URL=http://localhost:8000
INVENTORY_AGENT_URL=http://localhost:8001
CUSTOMER_SERVICE_AGENT_URL=http://localhost:8002

# Logging
LOG_LEVEL=INFO
LOG_FORMAT=json

# Development Settings
DEBUG=False
RELOAD=True

# A2A Configuration
A2A_TIMEOUT=30.0
A2A_MAX_RETRIES=3

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/frontend/__init__.py ===
"""Frontend package for A2A Retail Demo."""

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/frontend/app.py ===
"""Simplified Frontend for A2A Retail Demo."""

import asyncio
import os
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Optional
from dataclasses import dataclass, field

import mesop as me
import requests

# Add project root to Python path
ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(ROOT))

from backend.utils.a2a_utils import A2AManager, send_message_to_agent, check_agent_health


@me.stateclass
class AppState:
    """Application state."""
    messages: List[dict] = field(default_factory=list)
    current_input: str = ""
    is_loading: bool = False
    error_message: Optional[str] = None
    
    # Agent status
    host_agent_online: bool = False
    inventory_agent_online: bool = False
    customer_service_agent_online: bool = False
    
    # Configuration
    host_agent_url: str = "http://localhost:8000"
    show_debug: bool = False


def check_agent_status():
    """Check the status of all agents."""
    state = me.state(AppState)
    
    try:
        # Check host agent
        try:
            response = requests.get(f"{state.host_agent_url}/.well-known/agent.json", timeout=5)
            state.host_agent_online = response.status_code == 200
        except:
            state.host_agent_online = False
        
        # Check inventory agent
        try:
            response = requests.get("http://localhost:8001/.well-known/agent.json", timeout=5)
            state.inventory_agent_online = response.status_code == 200
        except:
            state.inventory_agent_online = False
        
        # Check customer service agent
        try:
            response = requests.get("http://localhost:8002/.well-known/agent.json", timeout=5)
            state.customer_service_agent_online = response.status_code == 200
        except:
            state.customer_service_agent_online = False
            
    except Exception as e:
        state.error_message = f"Error checking agent status: {str(e)}"


async def send_message_to_host(message_text: str) -> str:
    """Send message to host agent via A2A."""
    try:
        response = await send_message_to_agent(
            "http://localhost:8000",
            message_text
        )
        return response or "No response from host agent"
    except Exception as e:
        return f"Error communicating with host agent: {str(e)}"


def on_input_change(e: me.InputEvent):
    """Handle input field changes."""
    me.state(AppState).current_input = e.value


async def on_send_message(e: me.ClickEvent):
    """Handle send message button click."""
    state = me.state(AppState)
    
    if not state.current_input.strip():
        return
    
    # Add user message
    user_message = {
        "role": "user",
        "content": state.current_input,
        "timestamp": datetime.now().isoformat(),
    }
    state.messages.append(user_message)
    
    message_text = state.current_input
    state.current_input = ""
    state.is_loading = True
    state.error_message = None
    
    try:
        # Send to host agent
        response = await send_message_to_host(message_text)
        
        # Add agent response
        agent_message = {
            "role": "agent", 
            "content": response,
            "timestamp": datetime.now().isoformat(),
        }
        state.messages.append(agent_message)
        
    except Exception as e:
        state.error_message = f"Error: {str(e)}"
    finally:
        state.is_loading = False


def on_refresh_status(e: me.ClickEvent):
    """Handle refresh status button click."""
    check_agent_status()


def on_clear_chat(e: me.ClickEvent):
    """Handle clear chat button click."""
    state = me.state(AppState)
    state.messages = []
    state.error_message = None


def on_toggle_debug(e: me.ClickEvent):
    """Toggle debug information display."""
    state = me.state(AppState)
    state.show_debug = not state.show_debug


def agent_status_card(name: str, online: bool, port: int):
    """Render an agent status card."""
    color = "#4caf50" if online else "#f44336"
    status = "Online" if online else "Offline"
    
    with me.box(
        style=me.Style(
            border=me.Border.all(me.BorderSide(width=2, color=color)),
            border_radius=6,
            padding=me.Padding.all(8),
            margin=me.Margin(right=10),
            min_width="160px",
        )
    ):
        me.text(name, type="subtitle-2")
        me.text(f"{status} • :{port}", style=me.Style(color=color))


def chat_message_bubble(message: dict):
    """Render a chat message bubble."""
    is_user = message["role"] == "user"
    align = "flex-end" if is_user else "flex-start"
    bg = "#1976d2" if is_user else "#e0e0e0"
    fg = "white" if is_user else "black"
    
    timestamp = message.get("timestamp", "")
    try:
        when = datetime.fromisoformat(timestamp.replace("Z", "+00:00")).strftime("%H:%M:%S")
    except:
        when = ""
    
    with me.box(style=me.Style(display="flex", justify_content=align, margin=me.Margin(bottom=10))):
        with me.box(
            style=me.Style(
                max_width="70%",
                background=bg,
                color=fg,
                padding=me.Padding.all(12),
                border_radius=8,
            )
        ):
            me.text(message["content"])
            if when:
                me.text(when, type="caption", style=me.Style(opacity=0.7, margin=me.Margin(top=5)))


@me.page(path="/", title="A2A Retail Demo")
def main_page():
    """Main application page."""
    state = me.state(AppState)
    
    # Check agent status on page load
    if not any([state.host_agent_online, state.inventory_agent_online, state.customer_service_agent_online]):
        check_agent_status()
    
    with me.box(style=me.Style(padding=me.Padding.all(20))):
        me.text("🛍️ A2A Retail Demo", type="headline-4", style=me.Style(margin=me.Margin(bottom=10)))
        me.text(
            "Demonstrating Google's Agent-to-Agent protocol with specialized retail agents",
            type="body-1",
            style=me.Style(margin=me.Margin(bottom=30), color="gray"),
        )
        
        # Agent status section
        with me.box(
            style=me.Style(
                background="#f5f5f5",
                padding=me.Padding.all(15),
                border_radius=8,
                margin=me.Margin(bottom=20),
            )
        ):
            me.text("Agent Status", type="subtitle-1")
            with me.box(style=me.Style(display="flex", margin=me.Margin(top=10), flex_wrap="wrap")):
                agent_status_card("Host Agent", state.host_agent_online, 8000)
                agent_status_card("Inventory Agent", state.inventory_agent_online, 8001)
                agent_status_card("Customer Service", state.customer_service_agent_online, 8002)
            
            with me.box(style=me.Style(margin=me.Margin(top=10))):
                me.button("Refresh Status", on_click=on_refresh_status, type="stroked")
                me.button("Clear Chat", on_click=on_clear_chat, type="stroked", style=me.Style(margin=me.Margin(left=10)))
                me.button("Debug Info", on_click=on_toggle_debug, type="stroked", style=me.Style(margin=me.Margin(left=10)))
        
        # Error display
        if state.error_message:
            with me.box(
                style=me.Style(
                    background="#ffebee",
                    border=me.Border.all(me.BorderSide(width=1, color="#f44336")),
                    border_radius=4,
                    padding=me.Padding.all(10),
                    margin=me.Margin(bottom=20),
                )
            ):
                me.text(state.error_message, style=me.Style(color="#d32f2f"))
        
        # Chat area
        with me.box(
            style=me.Style(
                border=me.Border.all(me.BorderSide(width=1, color="#e0e0e0")),
                border_radius=8,
                padding=me.Padding.all(20),
                min_height="400px",
                margin=me.Margin(bottom=20),
            )
        ):
            # Chat history
            with me.box(
                style=me.Style(
                    height="400px",
                    overflow_y="auto",
                    padding=me.Padding.all(10),
                    background="#fafafa",
                    border_radius=4,
                    margin=me.Margin(bottom=20),
                )
            ):
                if not state.messages:
                    me.text(
                        "🤖 Welcome! I'm your retail assistant powered by A2A protocol.",
                        style=me.Style(color="gray", font_style="italic"),
                    )
                    me.text("Try asking:", style=me.Style(margin=me.Margin(top=10), font_weight="bold"))
                    me.text("• 'Do you have Smart TVs in stock?'", style=me.Style(color="gray"))
                    me.text("• 'What's the status of order ORD-12345?'", style=me.Style(color="gray"))
                    me.text("• 'Show me wireless earbuds under $200'", style=me.Style(color="gray"))
                    me.text("• 'What are your store hours?'", style=me.Style(color="gray"))
                
                for message in state.messages:
                    chat_message_bubble(message)
                
                # Loading indicator
                if state.is_loading:
                    with me.box(style=me.Style(display="flex", justify_content="flex-start", margin=me.Margin(top=10))):
                        with me.box(
                            style=me.Style(
                                background="#e0e0e0",
                                padding=me.Padding.all(12),
                                border_radius=8,
                            )
                        ):
                            me.text("🤔 Processing your request via A2A protocol...", style=me.Style(color="gray"))
            
            # Input area
            with me.box(style=me.Style(display="flex", gap=10, align_items="center")):
                me.input(
                    label="Ask about products, orders, or store information...",
                    value=state.current_input,
                    on_input=on_input_change,
                    style=me.Style(flex_grow=1),
                    disabled=state.is_loading,
                )
                me.button(
                    "Send",
                    on_click=on_send_message,
                    type="raised",
                    disabled=state.is_loading or not state.current_input.strip(),
                )
        
        # Debug information
        if state.show_debug:
            with me.box(
                style=me.Style(
                    background="#f0f8ff",
                    border=me.Border.all(me.BorderSide(width=1, color="#2196f3")),
                    border_radius=4,
                    padding=me.Padding.all(15),
                    margin=me.Margin(top=20),
                )
            ):
                me.text("🔧 Debug Information", type="subtitle-1", style=me.Style(margin=me.Margin(bottom=10)))
                me.text(f"Host Agent URL: {state.host_agent_url}")
                me.text(f"Total Messages: {len(state.messages)}")
                me.text(f"Loading: {state.is_loading}")
                
                me.text("A2A Architecture:", style=me.Style(margin=me.Margin(top=10), font_weight="bold"))
                me.text("Frontend → Host Agent (8000) → [Inventory Agent (8001) | Customer Service Agent (8002)]")


if __name__ == "__main__":
    import uvicorn
    from werkzeug.serving import run_simple
    
    HOST = os.environ.get("MESOP_HOST", "127.0.0.1")
    PORT = int(os.environ.get("MESOP_PORT", "8080"))
    
    print(f"🚀 Starting A2A Retail Demo Frontend on http://{HOST}:{PORT}")
    
    try:
        wsgi_app = me.create_wsgi_app()
        run_simple(HOST, PORT, wsgi_app, use_reloader=False, use_debugger=True)
    except Exception as e:
        print(f"❌ Failed to start: {e}")
        import traceback
        traceback.print_exc()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/frontend/state/__init__.py ===


=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/frontend/state/host_agent_service.py ===
"""Host agent service for frontend-to-backend communication."""

import logging
from typing import Optional
from backend.utils.a2a_utils import send_message_to_agent, check_agent_health

logger = logging.getLogger(__name__)


async def UpdateAppState(app_state, conversation_id: str):
    """Update app state (stub for now)."""
    pass


async def UpdateApiKey(api_key: str) -> bool:
    """Update API key (stub for now)."""
    return True

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/frontend/state/state.py ===
"""Application state for the frontend."""

import mesop as me
from dataclasses import dataclass, field
from typing import List, Optional


@me.stateclass
class AppState:
    """Application state."""
    messages: List[dict] = field(default_factory=list)
    current_input: str = ""
    is_loading: bool = False
    error_message: Optional[str] = None
    
    # Agent status
    host_agent_online: bool = False
    inventory_agent_online: bool = False
    customer_service_agent_online: bool = False
    
    # Configuration
    host_agent_url: str = "http://localhost:8000"
    show_debug: bool = False
    
    # Additional state
    sidenav_open: bool = False
    current_conversation_id: str = ""
    polling_interval: int = 0

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/frontend/static/styles.css ===
/* Custom styles for A2A Retail Demo */

/* Animation for loading states */
@keyframes pulse {
    0% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
    100% {
        opacity: 1;
    }
}

.loading {
    animation: pulse 1.5s ease-in-out infinite;
}

/* Custom scrollbar for chat */
.chat-container::-webkit-scrollbar {
    width: 8px;
}

.chat-container::-webkit-scrollbar-track {
    background: #f1f1f1;
}

.chat-container::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

.chat-container::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* Hover effects for cards */
.inventory-card {
    transition: transform 0.2s, box-shadow 0.2s;
}

.inventory-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Status indicators */
.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
}

.status-online {
    background-color: #4caf50;
}

.status-offline {
    background-color: #f44336;
}

/* Message bubbles */
.message-bubble {
    max-width: 70%;
    word-wrap: break-word;
}

.message-bubble.user {
    background-color: #1976d2;
    color: white;
    margin-left: auto;
}

.message-bubble.agent {
    background-color: #e0e0e0;
    color: black;
}

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/__init__.py ===
"""A2A Retail Demo Backend Package."""

__version__ = "0.1.0"

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/config/__init__.py ===
"""Configuration module."""

from .settings import settings

__all__ = ["settings"]

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/config/settings.py ===
"""Configuration settings for the A2A Retail Demo."""

import os
from pathlib import Path
from typing import Optional

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

    # Google AI / Gemini Configuration
    google_api_key: str
    google_cloud_project: Optional[str] = None
    google_cloud_location: str = "us-central1"
    google_genai_use_vertexai: bool = False

    # Model Configuration
    gemini_model: str = "gemini-2.0-flash"
    temperature: float = 0.7
    max_tokens: int = 2048

    # A2A Server Configuration
    inventory_agent_port: int = 8001
    customer_service_agent_port: int = 8002

    # Mesop UI Configuration
    mesop_port: int = 8000

    # Agent URLs
    inventory_agent_url: str = "http://localhost:8001"
    customer_service_agent_url: str = "http://localhost:8002"

    # Logging
    log_level: str = "INFO"
    log_format: str = "json"

    # Development Settings
    debug: bool = False
    reload: bool = True

    # Paths
    @property
    def base_dir(self) -> Path:
        """Get the base directory of the project."""
        return Path(__file__).parent.parent.parent

    @property
    def data_dir(self) -> Path:
        """Get the data directory."""
        data_dir = self.base_dir / "data"
        data_dir.mkdir(exist_ok=True)
        return data_dir

    @property
    def logs_dir(self) -> Path:
        """Get the logs directory."""
        logs_dir = self.base_dir / "logs"
        logs_dir.mkdir(exist_ok=True)
        return logs_dir


# Create a singleton instance
settings = Settings()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/tests/__init__.py ===
"""Test package for A2A Retail Demo."""

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/__init__.py ===
"""Agents package."""

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/inventory_agent_a2a/server.py ===
"""Inventory Agent A2A Server."""

import logging
import os
import click
from dotenv import load_dotenv

from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentSkill,
)

from .agent import InventoryAgent
from .agent_executor import InventoryAgentExecutor

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MissingAPIKeyError(Exception):
    """Exception for missing API key."""
    pass


@click.command()
@click.option("--host", default="localhost", help="Host to run the server on")
@click.option("--port", default=8001, help="Port to run the server on")
def main(host: str, port: int):
    """Start the Inventory Agent A2A server."""
    try:
        # Check for API key
        if not os.getenv("GOOGLE_API_KEY"):
            raise MissingAPIKeyError(
                "GOOGLE_API_KEY environment variable not set."
            )
        
        # Define agent capabilities
        capabilities = AgentCapabilities(streaming=True)
        
        # Define agent skills
        skill = AgentSkill(
            id="inventory_management",
            name="Inventory Management",
            description="Manages retail product inventory, stock levels, and availability checks",
            tags=["inventory", "products", "stock", "retail"],
            examples=[
                "Do you have Smart TVs in stock?",
                "Check availability of product prod_001",
                "Search for wireless earbuds",
                "Show me products under $50",
                "What items are low in stock?",
            ],
        )
        
        # Create agent card
        agent_card = AgentCard(
            name="Inventory Management Agent",
            description="Manages retail product inventory, stock levels, and availability. Can check product availability, search products by various criteria, and monitor low stock items.",
            url=f"http://{host}:{port}/",
            version="1.0.0",
            defaultInputModes=InventoryAgent.SUPPORTED_CONTENT_TYPES,
            defaultOutputModes=InventoryAgent.SUPPORTED_CONTENT_TYPES,
            capabilities=capabilities,
            skills=[skill],
        )
        
        # Create request handler
        request_handler = DefaultRequestHandler(
            agent_executor=InventoryAgentExecutor(),
            task_store=InMemoryTaskStore(),
        )
        
        # Create A2A server
        server = A2AStarletteApplication(
            agent_card=agent_card,
            http_handler=request_handler,
        )
        
        # Start server
        import uvicorn
        logger.info(f"Starting Inventory Agent on http://{host}:{port}")
        uvicorn.run(server.build(), host=host, port=port)
        
    except MissingAPIKeyError as e:
        logger.error(f"Error: {e}")
        exit(1)
    except Exception as e:
        logger.error(f"An error occurred during server startup: {e}")
        exit(1)


if __name__ == "__main__":
    main()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/inventory_agent_a2a/__init__.py ===
"""Inventory Agent using A2A Protocol."""

from .agent import InventoryAgent
from .agent_executor import InventoryAgentExecutor

__all__ = ["InventoryAgent", "InventoryAgentExecutor"]

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/inventory_agent_a2a/agent_executor.py ===
"""Inventory Agent Executor for A2A Protocol."""

import logging
from typing import Any, Dict

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import (
    InternalError,
    InvalidParamsError,
    Part,
    Task,
    TaskState,
    TextPart,
    UnsupportedOperationError,
)
from a2a.utils import (
    new_agent_text_message,
    new_task,
)
from a2a.utils.errors import ServerError

from .agent import InventoryAgent

logger = logging.getLogger(__name__)


class InventoryAgentExecutor(AgentExecutor):
    """Inventory Agent Executor for A2A Protocol."""
    
    def __init__(self):
        self.agent = InventoryAgent()
    
    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        """Execute inventory agent request."""
        error = self._validate_request(context)
        if error:
            raise ServerError(error=InvalidParamsError())
        
        query = context.get_user_input()
        task = context.current_task
        
        # Create new task if none exists
        if not task:
            task = new_task(context.message)
            event_queue.enqueue_event(task)
        
        updater = TaskUpdater(event_queue, task.id, task.contextId)
        
        try:
            async for item in self.agent.stream(query, task.contextId):
                is_task_complete = item["is_task_complete"]
                
                if not is_task_complete:
                    # Update status with progress message
                    updater.update_status(
                        TaskState.working,
                        new_agent_text_message(
                            item["updates"],
                            task.contextId,
                            task.id,
                        ),
                    )
                else:
                    # Task is complete, add artifact and finish
                    updater.add_artifact(
                        [Part(root=TextPart(text=item["content"]))],
                        name="inventory_result",
                    )
                    updater.complete()
                    break
                    
        except Exception as e:
            logger.error(f"Error executing inventory agent: {e}")
            raise ServerError(error=InternalError()) from e
    
    def _validate_request(self, context: RequestContext) -> bool:
        """Validate the incoming request."""
        # Basic validation - ensure we have user input
        try:
            user_input = context.get_user_input()
            return not user_input or not user_input.strip()
        except Exception:
            return True
    
    async def cancel(
        self,
        request: RequestContext,
        event_queue: EventQueue
    ) -> Task | None:
        """Cancel a task - not supported for this agent."""
        raise ServerError(error=UnsupportedOperationError())

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/inventory_agent_a2a/agent.py ===
"""Inventory Agent using Google ADK and A2A Protocol."""

import asyncio
import json
import logging
import os
from typing import Any, AsyncIterable, Dict, List, Optional

from google.adk.agents import Agent
from google.adk.artifacts import InMemoryArtifactService
from google.adk.memory.in_memory_memory_service import InMemoryMemoryService
from google.adk.runners import Runner
from google.adk.sessions.in_memory_session_service import InMemorySessionService
from google.genai import types

logger = logging.getLogger(__name__)

# Sample inventory data
INVENTORY_DATA = [
    {
        "id": "prod_001",
        "name": "Smart TV 55-inch 4K",
        "description": "Ultra HD smart LED TV with built-in streaming apps",
        "category": "electronics",
        "price": 699.99,
        "stock_quantity": 25,
        "stock_status": "In Stock",
        "sku": "TV55-4K-001",
        "brand": "TechVision",
    },
    {
        "id": "prod_002", 
        "name": "Wireless Earbuds Pro",
        "description": "Noise cancelling wireless earbuds with 24h battery",
        "category": "electronics",
        "price": 199.99,
        "stock_quantity": 150,
        "stock_status": "In Stock",
        "sku": "WE-PRO-002",
        "brand": "AudioMax",
    },
    {
        "id": "prod_003",
        "name": "Cotton T-Shirt",
        "description": "100% organic cotton T-shirt, multiple colors",
        "category": "clothing",
        "price": 29.99,
        "stock_quantity": 8,
        "stock_status": "Low Stock",
        "sku": "TS-COT-003",
        "brand": "EcoWear",
    },
    {
        "id": "prod_004",
        "name": "Coffee Maker Deluxe",
        "description": "12-cup programmable coffee maker with thermal carafe",
        "category": "home",
        "price": 89.99,
        "stock_quantity": 0,
        "stock_status": "Out of Stock",
        "sku": "CM-DLX-004",
        "brand": "BrewMaster",
    },
    {
        "id": "prod_005",
        "name": "Yoga Mat Premium",
        "description": "Extra thick non-slip yoga mat with carrying strap",
        "category": "sports",
        "price": 49.99,
        "stock_quantity": 45,
        "stock_status": "In Stock",
        "sku": "YM-PRM-005",
        "brand": "FitLife",
    },
]


def check_product_availability(product_id: str) -> Dict[str, Any]:
    """Check if a specific product is available in inventory."""
    for product in INVENTORY_DATA:
        if product["id"] == product_id or product["sku"].lower() == product_id.lower():
            return {
                "status": "success",
                "product_id": product["id"],
                "name": product["name"],
                "available": product["stock_quantity"] > 0,
                "stock_quantity": product["stock_quantity"],
                "stock_status": product["stock_status"],
                "price": product["price"],
            }
    
    return {
        "status": "error",
        "error_message": f"Product {product_id} not found",
    }


def search_products(
    query: Optional[str] = None,
    category: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    in_stock_only: bool = True,
) -> Dict[str, Any]:
    """Search for products based on various criteria."""
    results = []
    
    for product in INVENTORY_DATA:
        # Filter by category
        if category and product["category"].lower() != category.lower():
            continue
            
        # Filter by price range
        if min_price and product["price"] < min_price:
            continue
        if max_price and product["price"] > max_price:
            continue
            
        # Filter by stock availability
        if in_stock_only and product["stock_quantity"] == 0:
            continue
            
        # Filter by search query
        if query:
            query_lower = query.lower()
            if not any([
                query_lower in product["name"].lower(),
                query_lower in product["description"].lower(),  
                query_lower in product["brand"].lower() if product["brand"] else False,
                query_lower in product["category"].lower(),
            ]):
                continue
        
        results.append(product)
    
    return {
        "status": "success",
        "total_count": len(results),
        "products": results,
    }


def get_low_stock_items(threshold: int = 10) -> Dict[str, Any]:
    """Get items that are low in stock."""
    low_stock_items = [
        {
            "id": product["id"],
            "name": product["name"],
            "current_stock": product["stock_quantity"],
            "category": product["category"],
            "sku": product["sku"],
        }
        for product in INVENTORY_DATA
        if 0 < product["stock_quantity"] < threshold
    ]
    
    return {
        "status": "success",
        "threshold": threshold,
        "count": len(low_stock_items),
        "products": low_stock_items,
    }


class InventoryAgent:
    """Inventory management agent that handles product availability and stock levels."""
    
    SUPPORTED_CONTENT_TYPES = ["text", "text/plain"]
    
    def __init__(self):
        self._agent = self._build_agent()
        self._user_id = "inventory_agent_user"
        self._runner = Runner(
            app_name=self._agent.name,
            agent=self._agent,
            artifact_service=InMemoryArtifactService(),
            session_service=InMemorySessionService(),
            memory_service=InMemoryMemoryService(),
        )
    
    def get_processing_message(self) -> str:
        return "Checking inventory..."
    
    def _build_agent(self) -> Agent:
        """Build the ADK agent for inventory management."""
        return Agent(
            name="inventory_agent",
            model="gemini-2.0-flash",
            description="Retail inventory management agent that handles product availability, stock levels, and product searches.",
            instruction="""You are an inventory management assistant for a retail organization. Your role is to:

1. Check product availability and stock levels
2. Search for products based on various criteria (name, category, price range)
3. Monitor low stock items
4. Provide accurate inventory information

Always provide clear, accurate information about product availability and stock status. 
When products are out of stock, mention alternative products if available.
Format your responses in a helpful and organized manner.

Use the available tools to:
- check_product_availability: Check if a specific product is in stock
- search_products: Search for products by name, category, or other criteria
- get_low_stock_items: Get items that are running low in stock

When responding with product information, format it clearly with details like:
- Product name and ID
- Price
- Stock status and quantity
- Brand and category
""",
            tools=[
                check_product_availability,
                search_products,
                get_low_stock_items,
            ],
        )
    
    async def stream(self, query: str, session_id: str) -> AsyncIterable[Dict[str, Any]]:
        """Stream responses from the inventory agent."""
        try:
            session = await self._runner.session_service.get_session(
                app_name=self._agent.name,
                user_id=self._user_id,
                session_id=session_id,
            )
            
            if session is None:
                session = await self._runner.session_service.create_session(
                    app_name=self._agent.name,
                    user_id=self._user_id,
                    state={},
                    session_id=session_id,
                )
            
            content = types.Content(
                role="user",
                parts=[types.Part.from_text(text=query)]
            )
            
            async for event in self._runner.run_async(
                user_id=self._user_id,
                session_id=session.id,
                new_message=content
            ):
                if event.is_final_response():
                    response = ""
                    if (event.content and event.content.parts and 
                        event.content.parts[0].text):
                        response = "\n".join([
                            p.text for p in event.content.parts if p.text
                        ])
                    elif (event.content and event.content.parts and 
                          any([p.function_response for p in event.content.parts])):
                        # Handle function call responses
                        for part in event.content.parts:
                            if part.function_response:
                                response = json.dumps(part.function_response.response, indent=2)
                                break
                    
                    yield {
                        "is_task_complete": True,
                        "content": response,
                    }
                else:
                    yield {
                        "is_task_complete": False,
                        "updates": self.get_processing_message(),
                    }
        
        except Exception as e:
            logger.error(f"Error in inventory agent stream: {e}")
            yield {
                "is_task_complete": True,
                "content": f"Error processing inventory request: {str(e)}",
            }

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/host_agent/server.py ===
"""Host Agent A2A Server - Using Official A2A SDK."""

import logging
import os
import click
from dotenv import load_dotenv

# Import the correct A2A components
from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentSkill,
)

from .agent import HostAgent
from .agent_executor import HostAgentExecutor

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@click.command()
@click.option("--host", default="localhost", help="Host to run the server on")
@click.option("--port", default=8000, help="Port to run the server on")
def main(host: str, port: int):
    """Start the Host Agent A2A server."""
    try:
        # Check for API key
        if not os.getenv("GOOGLE_API_KEY"):
            raise Exception("GOOGLE_API_KEY environment variable not set.")
        
        # Define agent capabilities
        capabilities = AgentCapabilities(streaming=True)
        
        # Define agent skills
        skill = AgentSkill(
            id="retail_coordination",
            name="Retail Service Coordination",
            description="Coordinates between customer service and inventory management",
            tags=["retail", "coordination", "customer service", "inventory"],
            examples=[
                "Do you have Smart TVs in stock?",
                "What's the status of order ORD-12345?",
                "Help me with a return",
                "Show me products under $50",
                "What are your store hours?",
            ],
        )
        
        # Create agent card
        agent_card = AgentCard(
            name="Retail Host Agent",
            description="Orchestrates between customer service and inventory management agents for a seamless retail experience",
            url=f"http://{host}:{port}/",
            version="1.0.0",
            defaultInputModes=HostAgent.SUPPORTED_CONTENT_TYPES,
            defaultOutputModes=HostAgent.SUPPORTED_CONTENT_TYPES,
            capabilities=capabilities,
            skills=[skill],
        )
        
        # Create request handler
        request_handler = DefaultRequestHandler(
            agent_executor=HostAgentExecutor(),
            task_store=InMemoryTaskStore(),
        )
        
        # Create A2A server
        server = A2AStarletteApplication(
            agent_card=agent_card,
            http_handler=request_handler,
        )
        
        # Start server
        import uvicorn
        logger.info(f"Starting Host Agent on http://{host}:{port}")
        uvicorn.run(server.build(), host=host, port=port)
        
    except Exception as e:
        logger.error(f"Server startup error: {e}")
        exit(1)


if __name__ == "__main__":
    main()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/host_agent/__init__.py ===
"""Host Agent using A2A Protocol."""

from .agent import HostAgent
from .agent_executor import HostAgentExecutor

__all__ = ["HostAgent", "HostAgentExecutor"]

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/host_agent/agent_executor.py ===
"""Host Agent Executor for A2A Protocol."""

import logging
from typing import Any, Dict

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import (
    InternalError,
    InvalidParamsError,
    Part,
    Task,
    TaskState,
    TextPart,
    UnsupportedOperationError,
)
from a2a.utils import (
    new_agent_text_message,
    new_task,
)
from a2a.utils.errors import ServerError

from .agent import HostAgent

logger = logging.getLogger(__name__)


class HostAgentExecutor(AgentExecutor):
    """Host Agent Executor for A2A Protocol."""
    
    def __init__(self):
        self.agent = HostAgent()
    
    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        """Execute host agent request."""
        error = self._validate_request(context)
        if error:
            raise ServerError(error=InvalidParamsError())
        
        query = context.get_user_input()
        task = context.current_task
        
        # Create new task if none exists
        if not task:
            task = new_task(context.message)
            event_queue.enqueue_event(task)
        
        updater = TaskUpdater(event_queue, task.id, task.contextId)
        
        try:
            async for item in self.agent.stream(query, task.contextId):
                is_task_complete = item["is_task_complete"]
                
                if not is_task_complete:
                    # Update status with progress message
                    updater.update_status(
                        TaskState.working,
                        new_agent_text_message(
                            item["updates"],
                            task.contextId,
                            task.id,
                        ),
                    )
                else:
                    # Task is complete, add artifact and finish
                    updater.add_artifact(
                        [Part(root=TextPart(text=item["content"]))],
                        name="host_response",
                    )
                    updater.complete()
                    break
                    
        except Exception as e:
            logger.error(f"Error executing host agent: {e}")
            raise ServerError(error=InternalError()) from e
    
    def _validate_request(self, context: RequestContext) -> bool:
        """Validate the incoming request."""
        # Basic validation - ensure we have user input
        try:
            user_input = context.get_user_input()
            return not user_input or not user_input.strip()
        except Exception:
            return True
    
    async def cancel(
        self,
        request: RequestContext,
        event_queue: EventQueue
    ) -> Task | None:
        """Cancel a task - not supported for this agent."""
        raise ServerError(error=UnsupportedOperationError())

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/host_agent/agent.py ===
"""Host Agent that orchestrates between Customer Service and Inventory agents.

Using A2A SDK's built-in utilities.
"""

import logging
import uuid
from typing import Any, AsyncIterable, Dict

import httpx
from a2a.client import A2AClient
from a2a.types import (
    AgentCard, 
    Message, 
    Part, 
    Role, 
    TextPart,
    SendMessageRequest,
    MessageSendParams,
)
from a2a.utils import get_message_text  # Use A2A's built-in utilities
from google.adk.agents import Agent
from google.adk.artifacts import InMemoryArtifactService
from google.adk.memory.in_memory_memory_service import InMemoryMemoryService
from google.adk.runners import Runner
from google.adk.sessions.in_memory_session_service import InMemorySessionService
from google.genai import types

logger = logging.getLogger(__name__)


async def call_customer_service_agent(query: str) -> str:
    """Forward query to Customer Service Agent over A2A."""
    try:
        async with httpx.AsyncClient() as hc:
            # Get the agent card first to initialize client properly
            client = await A2AClient.get_client_from_agent_card_url(
                httpx_client=hc,
                base_url="http://localhost:8002"
            )
            
            # Create proper message
            message = Message(
                messageId=str(uuid.uuid4()),
                role=Role.user,
                parts=[Part(root=TextPart(text=query))]
            )
            
            # Send using new API
            request = SendMessageRequest(
                params=MessageSendParams(message=message)
            )
            response = await client.send_message(request)
            
            # Extract response properly
            if hasattr(response, 'root'):
                result = response.root.result
            else:
                result = response.result
            
            # Handle Task response
            if hasattr(result, 'artifacts') and result.artifacts:
                # Use A2A utils to extract text from artifacts
                for artifact in result.artifacts:
                    text = get_message_text(
                        Message(
                            messageId="temp",
                            role=Role.agent,
                            parts=artifact.parts
                        )
                    )
                    if text:
                        return text
            # Handle Message response
            elif hasattr(result, 'parts'):
                return get_message_text(result)
            
            return "No response from customer service agent"
            
    except Exception as e:
        logger.error(f"Error calling customer service agent: {e}", exc_info=True)
        return f"Customer service error: {str(e)}"


async def call_inventory_agent(query: str) -> str:
    """Forward query to Inventory Agent over A2A."""
    try:
        async with httpx.AsyncClient() as hc:
            # Get the agent card first to initialize client properly
            client = await A2AClient.get_client_from_agent_card_url(
                httpx_client=hc,
                base_url="http://localhost:8001"
            )
            
            # Create proper message
            message = Message(
                messageId=str(uuid.uuid4()),
                role=Role.user,
                parts=[Part(root=TextPart(text=query))]
            )
            
            # Send using new API
            request = SendMessageRequest(
                params=MessageSendParams(message=message)
            )
            response = await client.send_message(request)
            
            # Extract response properly
            if hasattr(response, 'root'):
                result = response.root.result
            else:
                result = response.result
            
            # Handle Task response
            if hasattr(result, 'artifacts') and result.artifacts:
                # Use A2A utils to extract text from artifacts
                for artifact in result.artifacts:
                    text = get_message_text(
                        Message(
                            messageId="temp",
                            role=Role.agent,
                            parts=artifact.parts
                        )
                    )
                    if text:
                        return text
            # Handle Message response  
            elif hasattr(result, 'parts'):
                return get_message_text(result)
            
            return "No response from inventory agent"
            
    except Exception as e:
        logger.error(f"Error calling inventory agent: {e}", exc_info=True)
        return f"Inventory error: {str(e)}"


async def get_agent_status() -> str:
    """Return online/offline status for remote agents."""
    lines = []
    async with httpx.AsyncClient() as hc:
        for name, url in [
            ("Inventory Agent", "http://localhost:8001"),
            ("Customer Service Agent", "http://localhost:8002"),
        ]:
            try:
                client = await A2AClient.get_client_from_agent_card_url(
                    httpx_client=hc,
                    base_url=url
                )
                lines.append(f"✅ {name}: Online")
            except Exception as e:
                logger.error(f"Error checking {name}: {e}")
                lines.append(f"❌ {name}: Offline")
    return "\n".join(lines)


class HostAgent:
    """Coordinates between Inventory and Customer Service agents."""

    SUPPORTED_CONTENT_TYPES = ["text", "text/plain"]

    def __init__(self) -> None:
        self._agent = self._build_agent()
        self._user_id = "host_agent_user"
        self._runner = Runner(
            app_name=self._agent.name,
            agent=self._agent,
            artifact_service=InMemoryArtifactService(),
            session_service=InMemorySessionService(),
            memory_service=InMemoryMemoryService(),
        )

    @staticmethod
    def get_processing_message() -> str:
        return "Coordinating with specialized agents..."

    def _build_agent(self) -> Agent:
        return Agent(
            name="host_agent",
            model="gemini-2.0-flash",
            description="Host agent orchestrating retail queries.",
            instruction=(
                "You are a host agent that coordinates between specialized retail agents.\n\n"
                "Route queries as follows:\n"
                "- Order status, returns, store hours → Customer Service Agent\n"
                "- Product availability, stock levels → Inventory Agent\n"
                "- For ambiguous queries, use your judgment or ask for clarification\n\n"
                "Always use the appropriate agent tools to get information."
            ),
            tools=[
                call_customer_service_agent,
                call_inventory_agent,
                get_agent_status,
            ],
        )

    async def stream(self, query: str, session_id: str) -> AsyncIterable[Dict[str, Any]]:
        try:
            session = await self._runner.session_service.get_session(
                app_name=self._agent.name,
                user_id=self._user_id,
                session_id=session_id,
            )
            if session is None:
                session = await self._runner.session_service.create_session(
                    app_name=self._agent.name,
                    user_id=self._user_id,
                    state={},
                    session_id=session_id,
                )

            content = types.Content(role="user", parts=[types.Part.from_text(text=query)])

            async for event in self._runner.run_async(
                user_id=self._user_id,
                session_id=session.id,
                new_message=content,
            ):
                if event.is_final_response():
                    response_txt = ""
                    if event.content and event.content.parts and event.content.parts[0].text:
                        response_txt = "\n".join(p.text for p in event.content.parts if p.text)
                    elif event.content and any(p.function_response for p in event.content.parts):
                        for p in event.content.parts:
                            if p.function_response:
                                response_txt = str(p.function_response.response)
                                break
                    yield {"is_task_complete": True, "content": response_txt}
                else:
                    yield {"is_task_complete": False, "updates": self.get_processing_message()}
        except Exception as exc:
            logger.error("Error in host agent stream: %s", exc, exc_info=True)
            yield {"is_task_complete": True, "content": f"Error coordinating request: {exc}"}

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/customer_service_a2a/server.py ===
"""Customer Service Agent A2A Server."""

import logging
import os
import click
from dotenv import load_dotenv

from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentSkill,
)

from .agent import CustomerServiceAgent
from .agent_executor import CustomerServiceAgentExecutor

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MissingAPIKeyError(Exception):
    """Exception for missing API key."""
    pass


@click.command()
@click.option("--host", default="localhost", help="Host to run the server on")
@click.option("--port", default=8002, help="Port to run the server on")
def main(host: str, port: int):
    """Start the Customer Service Agent A2A server."""
    try:
        # Check for API key
        if not os.getenv("GOOGLE_API_KEY"):
            raise MissingAPIKeyError(
                "GOOGLE_API_KEY environment variable not set."
            )
        
        # Define agent capabilities
        capabilities = AgentCapabilities(streaming=True)
        
        # Define agent skills
        skill = AgentSkill(
            id="customer_service",
            name="Customer Service Support",
            description="Handles customer inquiries, order status, returns, and general support",
            tags=["customer service", "orders", "returns", "support"],
            examples=[
                "What's the status of my order ORD-12345?",
                "I want to return a product",
                "What are your store hours?",
                "Do you have Smart TVs in stock?",
                "I need help with my order",
            ],
        )
        
        # Create agent card
        agent_card = AgentCard(
            name="Customer Service Agent",
            description="Handles customer inquiries, order status checks, returns, and product availability questions. Can coordinate with inventory systems to provide real-time product information.",
            url=f"http://{host}:{port}/",
            version="1.0.0",
            defaultInputModes=CustomerServiceAgent.SUPPORTED_CONTENT_TYPES,
            defaultOutputModes=CustomerServiceAgent.SUPPORTED_CONTENT_TYPES,
            capabilities=capabilities,
            skills=[skill],
        )
        
        # Create request handler
        request_handler = DefaultRequestHandler(
            agent_executor=CustomerServiceAgentExecutor(),
            task_store=InMemoryTaskStore(),
        )
        
        # Create A2A server
        server = A2AStarletteApplication(
            agent_card=agent_card,
            http_handler=request_handler,
        )
        
        # Start server
        import uvicorn
        logger.info(f"Starting Customer Service Agent on http://{host}:{port}")
        uvicorn.run(server.build(), host=host, port=port)
        
    except MissingAPIKeyError as e:
        logger.error(f"Error: {e}")
        exit(1)
    except Exception as e:
        logger.error(f"An error occurred during server startup: {e}")
        exit(1)


if __name__ == "__main__":
    main()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/customer_service_a2a/__init__.py ===
"""Customer Service Agent using A2A Protocol."""

from .agent import CustomerServiceAgent
from .agent_executor import CustomerServiceAgentExecutor

__all__ = ["CustomerServiceAgent", "CustomerServiceAgentExecutor"]

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/customer_service_a2a/agent_executor.py ===
"""Customer Service Agent Executor for A2A Protocol."""

import logging
from typing import Any, Dict

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import (
    InternalError,
    InvalidParamsError,
    Part,
    Task,
    TaskState,
    TextPart,
    UnsupportedOperationError,
)
from a2a.utils import (
    new_agent_text_message,
    new_task,
)
from a2a.utils.errors import ServerError

from .agent import CustomerServiceAgent

logger = logging.getLogger(__name__)


class CustomerServiceAgentExecutor(AgentExecutor):
    """Customer Service Agent Executor for A2A Protocol."""
    
    def __init__(self):
        self.agent = CustomerServiceAgent()
    
    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        """Execute customer service agent request."""
        error = self._validate_request(context)
        if error:
            raise ServerError(error=InvalidParamsError())
        
        query = context.get_user_input()
        task = context.current_task
        
        # Create new task if none exists
        if not task:
            task = new_task(context.message)
            event_queue.enqueue_event(task)
        
        updater = TaskUpdater(event_queue, task.id, task.contextId)
        
        try:
            async for item in self.agent.stream(query, task.contextId):
                is_task_complete = item["is_task_complete"]
                require_user_input = item.get("require_user_input", False)
                
                if not is_task_complete and not require_user_input:
                    # Update status with progress message
                    updater.update_status(
                        TaskState.working,
                        new_agent_text_message(
                            item["content"],
                            task.contextId,
                            task.id,
                        ),
                    )
                elif require_user_input:
                    # Need more input from user
                    updater.update_status(
                        TaskState.input_required,
                        new_agent_text_message(
                            item["content"],
                            task.contextId,
                            task.id,
                        ),
                        final=True,
                    )
                    break
                else:
                    # Task is complete, add artifact and finish
                    updater.add_artifact(
                        [Part(root=TextPart(text=item["content"]))],
                        name="customer_service_response",
                    )
                    updater.complete()
                    break
                    
        except Exception as e:
            logger.error(f"Error executing customer service agent: {e}")
            raise ServerError(error=InternalError()) from e
    
    def _validate_request(self, context: RequestContext) -> bool:
        """Validate the incoming request."""
        # Basic validation - ensure we have user input
        try:
            user_input = context.get_user_input()
            return not user_input or not user_input.strip()
        except Exception:
            return True
    
    async def cancel(
        self,
        request: RequestContext,
        event_queue: EventQueue
    ) -> Task | None:
        """Cancel a task - not supported for this agent."""
        raise ServerError(error=UnsupportedOperationError())

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/agents/customer_service_a2a/agent.py ===
"""Customer Service Agent using LangGraph and A2A Protocol.

Fixed version with proper A2A client usage and error handling.
"""

from __future__ import annotations

import asyncio
import json
import logging
import re
import uuid
from collections.abc import AsyncIterable
from typing import Any, Dict, List, Literal

import httpx
from a2a.client import A2AClient
from a2a.types import (
    Message, 
    Part, 
    Role, 
    TextPart,
    SendMessageRequest,
    MessageSendParams,
)
from langchain_core.messages import AIMessage, HumanMessage, SystemMessage, ToolMessage
from langchain_core.tools import tool
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import END, StateGraph
from langgraph.prebuilt import ToolNode
from pydantic import BaseModel

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Mock data
# ---------------------------------------------------------------------------

ORDERS: Dict[str, Dict[str, Any]] = {
    "ORD-12345": {
        "status": "shipped",
        "tracking_number": "1Z999AA1012345678",
        "items": ["Smart TV 55-inch 4K"],
        "total": 699.99,
    },
    "ORD-67890": {
        "status": "processing",
        "items": ["Wireless Earbuds Pro", "Cotton T-Shirt"],
        "total": 229.98,
    },
}

STORE_HOURS = {
    "monday-friday": "9:00 AM - 9:00 PM",
    "saturday": "9:00 AM - 10:00 PM",
    "sunday": "10:00 AM - 7:00 PM",
}

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _clean_order_id(raw: str) -> str:
    """Return canonical `ORD-xxxxx` (upper-case, no trailing punctuation)."""
    oid = re.sub(r"[!?.,]+$", "", raw.strip()).upper()
    return oid if oid.startswith("ORD-") else f"ORD-{oid.lstrip('ORD-')}"

# ---------------------------------------------------------------------------
# LangChain tools
# ---------------------------------------------------------------------------


@tool
def check_order_status(order_id: str) -> str:
    """Check the status of an order by order ID. Use this when a customer asks about their order."""
    logger.info(f"Checking order status for: {order_id}")
    order_id = _clean_order_id(order_id)
    order = ORDERS.get(order_id)
    if not order:
        return f"I couldn't find order {order_id}. Please verify the order number."
    
    parts = [f"Order {order_id} is currently {order['status']}."]
    if order["status"] == "shipped":
        parts.append(f"Tracking number: {order['tracking_number']}")
    parts.append(f"Items: {', '.join(order['items'])}")
    parts.append(f"Total: ${order['total']}")
    
    result = " ".join(parts)
    logger.info(f"Order status result: {result}")
    return result


@tool
def get_store_hours(location: str = "main") -> str:
    """Get the store hours for a specific location. Use this when asked about store hours or opening times."""
    logger.info(f"Getting store hours for location: {location}")
    return (
        f"Store hours for {location} location:\n"
        f"Monday-Friday: {STORE_HOURS['monday-friday']}\n"
        f"Saturday: {STORE_HOURS['saturday']}\n"
        f"Sunday: {STORE_HOURS['sunday']}"
    )


@tool
def process_return_request(order_id: str, product_name: str, reason: str) -> str:
    """Process a return request for a product. Use this when a customer wants to return an item."""
    logger.info(f"Processing return for order {order_id}, product: {product_name}, reason: {reason}")
    rid = f"RET-{_clean_order_id(order_id)[-5:]}"
    return (
        f"Return request {rid} has been created for {product_name} from order {order_id}. "
        f"Reason: {reason}. You will receive a return shipping label via email within 24 hours."
    )


async def _query_inventory(query: str) -> str:
    """Internal function to query the inventory agent using proper A2A API."""
    try:
        logger.info(f"Querying inventory agent with: {query}")
        
        async with httpx.AsyncClient() as hc:
            # Initialize client properly using agent card
            client = await A2AClient.get_client_from_agent_card_url(
                httpx_client=hc,
                base_url="http://localhost:8001"
            )
            
            # Create message with proper structure
            message = Message(
                messageId=str(uuid.uuid4()),
                role=Role.user,
                parts=[Part(root=TextPart(text=query))]
            )
            
            # Send using new API
            request = SendMessageRequest(
                params=MessageSendParams(message=message)
            )
            response = await client.send_message(request)
            
            # Log the response structure for debugging
            logger.debug(f"Response type: {type(response)}")
            logger.debug(f"Response: {response}")
            
            # Extract the actual result from response wrapper
            if hasattr(response, 'root'):
                # Response is wrapped in RootModel
                result = response.root.result
            else:
                # Direct response
                result = response.result if hasattr(response, 'result') else response
            
            # Now extract text from the result (which could be Task or Message)
            if hasattr(result, 'artifacts') and result.artifacts:
                # Task response with artifacts
                for artifact in result.artifacts:
                    if artifact.parts:
                        for part in artifact.parts:
                            if hasattr(part, 'root') and hasattr(part.root, 'text'):
                                return part.root.text
            elif hasattr(result, 'parts') and result.parts:
                # Direct Message response
                for part in result.parts:
                    if hasattr(part, 'root') and hasattr(part.root, 'text'):
                        return part.root.text
            elif hasattr(result, 'status') and hasattr(result.status, 'message'):
                # Task with status message
                if result.status.message and hasattr(result.status.message, 'parts'):
                    for part in result.status.message.parts:
                        if hasattr(part, 'root') and hasattr(part.root, 'text'):
                            return part.root.text
            
            logger.warning(f"Unable to extract text from response: {result}")
            return "Unable to get inventory information."
            
    except Exception as exc:
        logger.error(f"Inventory agent error: {exc}", exc_info=True)
        return f"Inventory system error: {str(exc)}"


@tool
async def check_inventory(query: str) -> str:
    """Check product inventory and availability. Use this when asked about product availability or stock."""
    return await _query_inventory(query)

# ---------------------------------------------------------------------------
# LangGraph wiring
# ---------------------------------------------------------------------------

memory = MemorySaver()


class ConversationState(BaseModel):
    """State for the conversation."""
    messages: List[Any]
    
    class Config:
        arbitrary_types_allowed = True


class CustomerServiceAgent:
    """LangGraph customer-service agent."""

    SYSTEM_INSTRUCTION = """You are a helpful customer service agent for an online retail store. 

Your primary responsibilities:
1. Check order status when customers ask about their orders
2. Provide store hours information
3. Process return requests
4. Check product inventory by querying the inventory system

You have access to the following tools:
- check_order_status: Use this to look up order information
- get_store_hours: Use this to provide store hours
- process_return_request: Use this to initiate returns
- check_inventory: Use this to check product availability

Always use the appropriate tool when handling customer requests. Be helpful, professional, and concise."""

    SUPPORTED_CONTENT_TYPES = ["text", "text/plain"]

    def __init__(self) -> None:
        self.model = ChatGoogleGenerativeAI(
            model="gemini-2.0-flash", 
            temperature=0.3,  # Lower temperature for more consistent responses
            convert_system_message_to_human=True
        )
        self.tools = [
            check_order_status,
            get_store_hours,
            process_return_request,
            check_inventory,
        ]
        self.graph = self._build_graph()

    def _build_graph(self):
        """Build the LangGraph state machine."""
        workflow = StateGraph(ConversationState)
        
        # Create tool node
        tool_node = ToolNode(self.tools)
        
        # Add nodes
        workflow.add_node("agent", self._call_model)
        workflow.add_node("tools", tool_node)
        
        # Set entry point
        workflow.set_entry_point("agent")
        
        # Add conditional edges
        workflow.add_conditional_edges(
            "agent",
            self._should_use_tools,
            {
                "tools": "tools",
                "end": END,
            }
        )
        
        # Add edge from tools back to agent
        workflow.add_edge("tools", "agent")
        
        # Compile with memory
        return workflow.compile(checkpointer=memory)

    def _call_model(self, state: ConversationState) -> Dict[str, Any]:
        """Call the LLM with the current conversation state."""
        messages = state.messages
        
        # Ensure we have system message
        if not messages or not isinstance(messages[0], SystemMessage):
            messages = [SystemMessage(content=self.SYSTEM_INSTRUCTION)] + messages
        
        logger.debug(f"Calling model with {len(messages)} messages")
        
        # Bind tools and invoke
        try:
            response = self.model.bind_tools(self.tools).invoke(messages)
            logger.debug(f"Model response: {response}")
            return {"messages": messages + [response]}
        except Exception as e:
            logger.error(f"Error calling model: {e}", exc_info=True)
            error_msg = AIMessage(content="I apologize, but I encountered an error processing your request. Please try again.")
            return {"messages": messages + [error_msg]}

    def _should_use_tools(self, state: ConversationState) -> Literal["tools", "end"]:
        """Determine if we should use tools or end the conversation."""
        messages = state.messages
        last_message = messages[-1]
        
        # Check if the last message has tool calls
        if hasattr(last_message, "tool_calls") and last_message.tool_calls:
            logger.debug(f"Using tools: {[tc.get('name') for tc in last_message.tool_calls]}")
            return "tools"
        
        logger.debug("No tool calls, ending conversation")
        return "end"

    async def stream(self, query: str, session_id: str) -> AsyncIterable[Dict[str, Any]]:
        """Stream responses for the given query."""
        try:
            logger.info(f"Customer service agent processing query: {query}")
            
            # Initialize conversation
            config = {"configurable": {"thread_id": session_id}}
            messages = [
                SystemMessage(content=self.SYSTEM_INSTRUCTION),
                HumanMessage(content=query)
            ]
            initial_state = ConversationState(messages=messages)
            
            # Track if we've sent any updates
            has_sent_update = False
            
            # Stream the graph execution
            async for event in self.graph.astream(
                initial_state.dict(), 
                config=config,
                stream_mode="values"
            ):
                if "messages" not in event:
                    continue
                    
                messages = event["messages"]
                if not messages:
                    continue
                
                last_message = messages[-1]
                logger.debug(f"Stream event - message type: {type(last_message).__name__}")
                
                # Handle tool calls
                if isinstance(last_message, AIMessage) and hasattr(last_message, "tool_calls") and last_message.tool_calls:
                    if not has_sent_update:
                        has_sent_update = True
                        yield {
                            "is_task_complete": False,
                            "require_user_input": False,
                            "content": "Looking up information..."
                        }
                
                # Handle tool responses
                elif isinstance(last_message, ToolMessage):
                    yield {
                        "is_task_complete": False,
                        "require_user_input": False,
                        "content": "Processing..."
                    }
                
                # Handle final AI response
                elif isinstance(last_message, AIMessage) and last_message.content:
                    logger.info(f"Final response: {last_message.content}")
                    yield {
                        "is_task_complete": True,
                        "require_user_input": False,
                        "content": last_message.content
                    }
                    break
            
        except Exception as exc:
            # Log the full exception details
            logger.error(f"Customer service stream error: {exc}", exc_info=True)
            
            # Return more specific error information for debugging
            error_message = f"Error processing request: {type(exc).__name__}: {str(exc)}"
            yield {
                "is_task_complete": True,
                "require_user_input": False,
                "content": error_message
            }

    def invoke(self, query: str, session_id: str) -> str:
        """Synchronous invoke for testing."""
        config = {"configurable": {"thread_id": session_id}}
        messages = [
            SystemMessage(content=self.SYSTEM_INSTRUCTION),
            HumanMessage(content=query)
        ]
        initial_state = ConversationState(messages=messages)
        
        try:
            result = self.graph.invoke(initial_state.dict(), config)
            messages = result.get("messages", [])
            
            # Find the last AI message
            for msg in reversed(messages):
                if isinstance(msg, AIMessage) and msg.content:
                    return msg.content
            
            return "I apologize, but I couldn't process your request."
        except Exception as e:
            logger.error(f"Error in invoke: {e}", exc_info=True)
            return f"Error: {type(e).__name__}: {str(e)}"

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/server/demo_server.py ===
"""Demo server implementation following A2A documentation pattern."""

import asyncio
import logging
import os
from typing import Dict, List, Optional
import httpx
from a2a.types import AgentCard, Message
from backend.hosts.multiagent.host_agent import HostAgent
from backend.hosts.multiagent.remote_agent_connection import RemoteAgentConnection, TaskCallbackArg
from backend.utils.a2a_utils import get_agent_card

logger = logging.getLogger(__name__)

class DemoServer:
    """Demo server that manages the host agent and remote agent connections."""
    
    def __init__(self):
        self.http_client = httpx.AsyncClient()
        self.remote_agents: List[RemoteAgentConnection] = []
        self.host_agent: Optional[HostAgent] = None
        
        # Initialize host agent
        self._initialize_host_agent()
    
    def _initialize_host_agent(self):
        """Initialize the host agent."""
        self.host_agent = HostAgent(
            remote_agents=self.remote_agents,
            http_client=self.http_client,
            task_callback=self._task_callback
        )
    
    def _task_callback(self, task: TaskCallbackArg, agent_card: AgentCard):
        """Handle task callbacks from remote agents."""
        logger.info(f"Task callback from {agent_card.name}: {task}")
    
    async def register_agent(self, agent_url: str) -> bool:
        """Register a remote agent."""
        try:
            agent_card = await get_agent_card(agent_url)
            if agent_card:
                agent_conn = RemoteAgentConnection(agent_card, self._task_callback)
                self.remote_agents.append(agent_conn)
                if self.host_agent:
                    self.host_agent.register_agent_card(agent_card)
                logger.info(f"Registered agent: {agent_card.name} at {agent_url}")
                return True
        except Exception as e:
            logger.error(f"Failed to register agent at {agent_url}: {e}")
        return False
    
    async def send_message(self, message: Message) -> Optional[Message]:
        """Send message through the host agent."""
        if self.host_agent:
            return await self.host_agent.route_message(message)
        return None
    
    async def get_registered_agents(self) -> List[AgentCard]:
        """Get list of registered agent cards."""
        return [agent.agent_card for agent in self.remote_agents]
    
    async def check_agent_health(self) -> Dict[str, bool]:
        """Check health of all registered agents."""
        health_status = {}
        for agent in self.remote_agents:
            try:
                await agent.get_agent_card()
                health_status[agent.agent_card.name] = True
            except Exception:
                health_status[agent.agent_card.name] = False
        return health_status
    
    async def shutdown(self):
        """Cleanup resources."""
        await self.http_client.aclose()

# Global demo server instance
demo_server = DemoServer()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/utils/__init__.py ===


=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/backend/utils/a2a_utils.py ===
"""Utility functions for A2A protocol operations."""

import asyncio
import logging
from typing import Optional, Dict, Any
import httpx

from a2a.client import A2AClient
from a2a.types import AgentCard, Message, Part, Role, TextPart

logger = logging.getLogger(__name__)


async def get_agent_card(agent_url: str) -> Optional[AgentCard]:
    """Get agent card from an A2A server."""
    try:
        client = A2AClient(url=agent_url)
        return await client.get_agent_card()
    except Exception as e:
        logger.error(f"Failed to get agent card from {agent_url}: {e}")
        return None


async def send_message_to_agent(
    agent_url: str,
    message_text: str,
    session_id: str = "default"
) -> Optional[str]:
    """Send a message to an A2A agent and get response."""
    try:
        client = A2AClient(url=agent_url)
        
        message = Message(
            role=Role.user,
            parts=[Part(root=TextPart(text=message_text))]
        )
        
        response = await client.send(message)
        
        if response.artifacts and response.artifacts[0].parts:
            return response.artifacts[0].parts[0].root.text
        
        return None
        
    except Exception as e:
        logger.error(f"Failed to send message to {agent_url}: {e}")
        return None


async def check_agent_health(agent_url: str) -> bool:
    """Check if an A2A agent is healthy."""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{agent_url}/.well-known/agent.json", timeout=5.0)
            return response.status_code == 200
    except Exception:
        return False


async def discover_agents(agent_urls: list[str]) -> Dict[str, AgentCard]:
    """Discover multiple agents and return their cards."""
    agents = {}
    
    for url in agent_urls:
        card = await get_agent_card(url)
        if card:
            agents[url] = card
    
    return agents


class A2AManager:
    """Manager for A2A agent interactions."""
    
    def __init__(self, agent_urls: Optional[Dict[str, str]] = None):
        self.agent_urls = agent_urls or {
            "host": "http://localhost:8000",
            "inventory": "http://localhost:8001", 
            "customer_service": "http://localhost:8002",
        }
        self.agent_cards = {}
    
    async def initialize(self):
        """Initialize the manager by discovering agents."""
        self.agent_cards = await discover_agents(list(self.agent_urls.values()))
        
    async def send_to_agent(self, agent_name: str, message: str) -> Optional[str]:
        """Send message to a specific agent."""
        if agent_name not in self.agent_urls:
            raise ValueError(f"Unknown agent: {agent_name}")
        
        return await send_message_to_agent(
            self.agent_urls[agent_name],
            message
        )
    
    async def check_all_agents(self) -> Dict[str, bool]:
        """Check health of all agents."""
        health_status = {}
        
        for name, url in self.agent_urls.items():
            health_status[name] = await check_agent_health(url)
        
        return health_status
    
    def get_agent_info(self, agent_name: str) -> Optional[AgentCard]:
        """Get agent card for a specific agent."""
        url = self.agent_urls.get(agent_name)
        if url:
            return self.agent_cards.get(url)
        return None

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/start_a2a_demo.sh ===
#!/usr/bin/env bash
#
# scripts/start_a2a_demo.sh  
# Start the A2A Retail Demo with proper A2A protocol
# ─────────────────────────────────────────────────────────────────────────────

set -Eeuo pipefail

# ── Locate project root & venv ──────────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
VENV_DIR="${PROJECT_ROOT}/.venv"

if [[ ! -x "${VENV_DIR}/bin/python" ]]; then
    echo "❌ Virtual environment not found at ${VENV_DIR}/bin/python"
    echo "   Please run: make setup"
    exit 1
fi

# ── Load environment variables ──────────────────────────────────────────────
if [[ -f "${PROJECT_ROOT}/.env" ]]; then
    echo "📋 Loading environment variables..."
    set -a
    source "${PROJECT_ROOT}/.env"
    set +a
else
    echo "⚠️  No .env file found. Using defaults."
fi

# ── Configuration ───────────────────────────────────────────────────────────
INVENTORY_PORT="${INVENTORY_AGENT_PORT:-8001}"
CUSTOMER_SERVICE_PORT="${CUSTOMER_SERVICE_AGENT_PORT:-8002}"
HOST_PORT="${HOST_AGENT_PORT:-8000}"
FRONTEND_PORT="${FRONTEND_PORT:-8080}"

echo "🔧 Configuration:"
echo "   Inventory Agent: http://localhost:${INVENTORY_PORT}"
echo "   Customer Service: http://localhost:${CUSTOMER_SERVICE_PORT}"
echo "   Host Agent: http://localhost:${HOST_PORT}"
echo "   Frontend: http://localhost:${FRONTEND_PORT}"
echo

# ── Cleanup function ────────────────────────────────────────────────────────
cleanup() {
    echo
    echo "🛑 Stopping all A2A agents..."
    
    # Kill by process name
    pkill -f "inventory_agent_a2a.server" 2>/dev/null || true
    pkill -f "customer_service_a2a.server" 2>/dev/null || true
    pkill -f "host_agent.server" 2>/dev/null || true
    pkill -f "frontend/app.py" 2>/dev/null || true
    
    # Kill by port
    for port in $INVENTORY_PORT $CUSTOMER_SERVICE_PORT $HOST_PORT $FRONTEND_PORT; do
        lsof -ti:$port | xargs kill -9 2>/dev/null || true
    done
    
    echo "✅ All services stopped"
    exit 0
}

trap cleanup EXIT INT TERM

# ── Check API key ───────────────────────────────────────────────────────────
if [[ -z "${GOOGLE_API_KEY:-}" ]]; then
    echo "❌ GOOGLE_API_KEY is not set in .env file"
    echo "   Please set your Google API key in .env"
    exit 1
fi

# ── Start agents ────────────────────────────────────────────────────────────
cd "${PROJECT_ROOT}"

echo "🚀 Starting A2A Retail Demo agents..."
echo

# Start inventory agent
echo "📦 Starting Inventory Agent on port ${INVENTORY_PORT}..."
"${VENV_DIR}/bin/python" -m backend.agents.inventory_agent_a2a.server --port $INVENTORY_PORT &
INVENTORY_PID=$!
sleep 3

# Start customer service agent  
echo "🎧 Starting Customer Service Agent on port ${CUSTOMER_SERVICE_PORT}..."
"${VENV_DIR}/bin/python" -m backend.agents.customer_service_a2a.server --port $CUSTOMER_SERVICE_PORT &
CUSTOMER_SERVICE_PID=$!
sleep 3

# Start host agent
echo "🏠 Starting Host Agent on port ${HOST_PORT}..."
"${VENV_DIR}/bin/python" -m backend.agents.host_agent.server --port $HOST_PORT &
HOST_PID=$!
sleep 3

# Start frontend
echo "🖥️  Starting Frontend on port ${FRONTEND_PORT}..."
MESOP_HOST=127.0.0.1 MESOP_PORT=$FRONTEND_PORT "${VENV_DIR}/bin/python" frontend/app.py &
FRONTEND_PID=$!
sleep 2

# ── Wait for services to be ready ──────────────────────────────────────────
echo "⏳ Waiting for services to be ready..."

check_service() {
    local url="$1"
    local name="$2"
    local max_attempts=15
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -s "$url" > /dev/null 2>&1; then
            echo "✅ $name is ready"
            return 0
        fi
        sleep 2
        attempt=$((attempt + 1))
    done
    
    echo "⚠️  $name may not be ready (no response from $url)"
    return 1
}

# Check each agent
check_service "http://localhost:${INVENTORY_PORT}/.well-known/agent.json" "Inventory Agent"
check_service "http://localhost:${CUSTOMER_SERVICE_PORT}/.well-known/agent.json" "Customer Service Agent"  
check_service "http://localhost:${HOST_PORT}/.well-known/agent.json" "Host Agent"
check_service "http://localhost:${FRONTEND_PORT}" "Frontend"

# ── Success banner ──────────────────────────────────────────────────────────
echo
echo "🎉 A2A Retail Demo is running!"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  Frontend:          http://localhost:${FRONTEND_PORT}"
echo "  Host Agent:        http://localhost:${HOST_PORT}" 
echo "  Inventory Agent:   http://localhost:${INVENTORY_PORT}"
echo "  Customer Service:  http://localhost:${CUSTOMER_SERVICE_PORT}"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo
echo "🔗 A2A Architecture:"
echo "   Frontend → Host Agent → [Inventory Agent | Customer Service Agent]"
echo
echo "💡 Try these queries in the frontend:"
echo "   • 'Do you have Smart TVs in stock?'"
echo "   • 'What's the status of order ORD-12345?'"
echo "   • 'Show me products under \$50'"
echo "   • 'What are your store hours?'"
echo
echo "Press Ctrl+C to stop all services"

# ── Wait for shutdown ───────────────────────────────────────────────────────
wait

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/cli_client.py ===
#!/usr/bin/env python3
"""CLI client for interacting with A2A agents."""

import asyncio
import sys
from pathlib import Path

# Add project root to path
ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(ROOT))

from backend.utils.a2a_utils import A2AManager, send_message_to_agent


class A2ACLIClient:
    """CLI client for A2A agent interaction."""
    
    def __init__(self):
        self.manager = A2AManager()
        self.current_agent = "host"
        
    async def initialize(self):
        """Initialize the client."""
        print("🔌 Initializing A2A CLI Client...")
        await self.manager.initialize()
        
        # Check agent status
        health = await self.manager.check_all_agents()
        print("\n📊 Agent Status:")
        for name, online in health.items():
            status = "✅ Online" if online else "❌ Offline"
            print(f"   {name}: {status}")
        
        print(f"\n🎯 Current agent: {self.current_agent}")
        
    def show_help(self):
        """Show help information."""
        print("\n🆘 Available Commands:")
        print("   /help          - Show this help")
        print("   /status        - Check agent status")
        print("   /switch <name> - Switch to agent (host, inventory, customer_service)")
        print("   /quit          - Exit the client")
        print("   /clear         - Clear screen")
        print("\n💬 A2A Queries:")
        print("   Just type your message to send to the current agent")
        print("\n📝 Example queries:")
        print("   • Do you have Smart TVs in stock?")
        print("   • What's the status of order ORD-12345?")
        print("   • Show me wireless earbuds under $200")
        print("   • What are your store hours?")
        
    async def handle_command(self, command: str) -> bool:
        """Handle CLI commands. Returns True to continue, False to quit."""
        command = command.strip()
        
        if command == "/help":
            self.show_help()
        elif command == "/quit":
            print("👋 Goodbye!")
            return False
        elif command == "/clear":
            import os
            os.system('clear' if os.name == 'posix' else 'cls')
        elif command == "/status":
            health = await self.manager.check_all_agents()
            print("\n📊 Agent Status:")
            for name, online in health.items():
                status = "✅ Online" if online else "❌ Offline"
                print(f"   {name}: {status}")
        elif command.startswith("/switch "):
            agent_name = command.split(" ", 1)[1].strip()
            if agent_name in self.manager.agent_urls:
                self.current_agent = agent_name
                print(f"🔄 Switched to {agent_name} agent")
            else:
                print(f"❌ Unknown agent: {agent_name}")
                print(f"   Available: {', '.join(self.manager.agent_urls.keys())}")
        else:
            print(f"❌ Unknown command: {command}")
            print("   Type /help for available commands")
        
        return True
    
    async def send_message(self, message: str):
        """Send a message to the current agent."""
        print(f"📤 Sending to {self.current_agent} agent: {message}")
        print("⏳ Processing...")
        
        try:
            response = await self.manager.send_to_agent(self.current_agent, message)
            if response:
                print(f"📥 Response:\n{response}")
            else:
                print("❌ No response received")
        except Exception as e:
            print(f"❌ Error: {e}")
    
    async def run(self):
        """Run the CLI client."""
        await self.initialize()
        self.show_help()
        
        print("\n" + "="*60)
        print("🎮 A2A CLI Client - Ready for interaction!")
        print("="*60)
        
        while True:
            try:
                # Show prompt
                prompt = f"\n[{self.current_agent}]> "
                user_input = input(prompt).strip()
                
                if not user_input:
                    continue
                
                # Handle commands
                if user_input.startswith("/"):
                    should_continue = await self.handle_command(user_input)
                    if not should_continue:
                        break
                else:
                    # Send message to agent
                    await self.send_message(user_input)
                    
            except KeyboardInterrupt:
                print("\n\n👋 Goodbye!")
                break
            except EOFError:
                print("\n\n👋 Goodbye!")
                break


async def main():
    """Main entry point."""
    client = A2ACLIClient()
    await client.run()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n👋 Goodbye!")
    except Exception as e:
        print(f"❌ CLI Client error: {e}")
        sys.exit(1)

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/stop_agents.sh ===
#!/usr/bin/env bash
#
# scripts/stop_agents.sh
# Stop all A2A Retail Demo services
# -----------------------------------------------------------------------------

echo "🛑 Stopping A2A Retail Demo services..."

# Kill processes by name (more comprehensive)
pkill -f "run_inventory_agent.py" 2>/dev/null && echo "✅ Stopped Inventory Agent" || echo "⚠️  Inventory Agent process not found"
pkill -f "run_customer_service_agent.py" 2>/dev/null && echo "✅ Stopped Customer Service Agent" || echo "⚠️  Customer Service Agent process not found" 
pkill -f "run_mesop_app.py" 2>/dev/null && echo "✅ Stopped Mesop UI" || echo "⚠️  Mesop UI process not found"
pkill -f "frontend/app.py" 2>/dev/null && echo "✅ Stopped Mesop UI (alternative)" || true

# Kill any Python processes on our ports
echo "🔍 Checking for processes on ports 8000, 8001, 8002..."

for port in 8000 8001 8002; do
  pids=$(lsof -ti:$port 2>/dev/null)
  if [[ -n "$pids" ]]; then
    echo "🔧 Killing processes on port $port: $pids"
    echo "$pids" | xargs kill -9 2>/dev/null || true
    echo "✅ Freed port $port"
  else
    echo "✓ Port $port is free"
  fi
done

# Kill any remaining uvicorn processes
pkill -f "uvicorn" 2>/dev/null && echo "✅ Stopped uvicorn processes" || true

# Kill any remaining Python processes that might be our agents
ps aux | grep -E "(inventory_agent|customer_service|mesop)" | grep -v grep | awk '{print $2}' | xargs kill -9 2>/dev/null || true

sleep 2

echo "🏁 All services stopped!"
echo
echo "🔍 Port status:"
for port in 8000 8001 8002; do
  if lsof -ti:$port >/dev/null 2>&1; then
    echo "❌ Port $port still in use"
  else
    echo "✅ Port $port is free"
  fi
done

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/test_a2a_setup.py ===
#!/usr/bin/env python3
"""Test script to verify A2A setup is working correctly."""

import asyncio
import sys
from pathlib import Path

# Add project root to path
ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(ROOT))

from backend.utils.a2a_utils import A2AManager, check_agent_health


async def test_agent_discovery():
    """Test agent discovery."""
    print("🔍 Testing agent discovery...")
    
    manager = A2AManager()
    await manager.initialize()
    
    for name, url in manager.agent_urls.items():
        card = manager.get_agent_info(name)
        if card:
            print(f"✅ {name}: {card.name} - {card.description}")
        else:
            print(f"❌ {name}: Not available at {url}")


async def test_agent_health():
    """Test agent health checks."""
    print("\n💪 Testing agent health...")
    
    agents = {
        "Host Agent": "http://localhost:8000",
        "Inventory Agent": "http://localhost:8001", 
        "Customer Service Agent": "http://localhost:8002",
    }
    
    for name, url in agents.items():
        healthy = await check_agent_health(url)
        status = "✅ Online" if healthy else "❌ Offline"
        print(f"   {name}: {status}")


async def test_a2a_communication():
    """Test A2A communication."""
    print("\n💬 Testing A2A communication...")
    
    manager = A2AManager()
    
    # Test host agent communication
    try:
        response = await manager.send_to_agent("host", "Check agent status")
        if response:
            print("✅ Host agent communication successful")
            print(f"   Response: {response[:100]}...")
        else:
            print("❌ No response from host agent")
    except Exception as e:
        print(f"❌ Host agent communication failed: {e}")


async def main():
    """Run all tests."""
    print("🧪 A2A Retail Demo - Setup Test")
    print("=" * 50)
    
    try:
        await test_agent_health()
        await test_agent_discovery()
        await test_a2a_communication()
        
        print("\n🎉 All tests completed!")
        print("\n💡 If any agents are offline:")
        print("   1. Make sure you've set GOOGLE_API_KEY in .env")
        print("   2. Run: make start")
        print("   3. Wait for all agents to be ready")
        
    except Exception as e:
        print(f"\n❌ Test failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/dev_utils.py ===
#!/usr/bin/env python3
"""Development utilities for A2A Retail Demo."""

import os
import sys
import subprocess
import time
from pathlib import Path
from typing import List, Dict, Any

# Add project root to path
ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(ROOT))


def check_python_version():
    """Check Python version requirements."""
    version = sys.version_info
    if version.major < 3 or (version.major == 3 and version.minor < 11):
        print("❌ Python 3.11+ required")
        return False
    print(f"✅ Python {version.major}.{version.minor}.{version.micro}")
    return True


def check_virtual_environment():
    """Check if virtual environment exists."""
    venv_path = ROOT / ".venv"
    if venv_path.exists():
        print("✅ Virtual environment found")
        return True
    print("❌ Virtual environment not found")
    return False


def check_environment_file():
    """Check if .env file exists and has required variables."""
    env_path = ROOT / ".env"
    if not env_path.exists():
        print("❌ .env file not found")
        return False
    
    # Check for required variables
    required_vars = ["GOOGLE_API_KEY"]
    missing_vars = []
    
    with open(env_path) as f:
        content = f.read()
        for var in required_vars:
            if f"{var}=" not in content or f"{var}=your-" in content:
                missing_vars.append(var)
    
    if missing_vars:
        print(f"❌ Missing environment variables: {', '.join(missing_vars)}")
        return False
    
    print("✅ Environment file configured")
    return True


def check_dependencies():
    """Check if dependencies are installed."""
    try:
        import google.adk
        import langchain
        import mesop
        import a2a
        print("✅ Core dependencies installed")
        return True
    except ImportError as e:
        print(f"❌ Missing dependencies: {e}")
        return False


def check_ports():
    """Check if required ports are available."""
    import socket
    
    ports = [8000, 8001, 8002, 8080]
    busy_ports = []
    
    for port in ports:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            if s.connect_ex(("localhost", port)) == 0:
                busy_ports.append(port)
    
    if busy_ports:
        print(f"⚠️  Ports in use: {', '.join(map(str, busy_ports))}")
        print("   You may need to stop other services")
        return False
    
    print("✅ Required ports available")
    return True


def setup_project():
    """Set up the project structure."""
    print("🛠️  Setting up project structure...")
    
    # Create directories
    directories = [
        "backend/agents/inventory_agent_a2a",
        "backend/agents/customer_service_a2a",
        "backend/host_agent",
        "backend/utils",
        "scripts",
        "logs",
        "data",
    ]
    
    for directory in directories:
        dir_path = ROOT / directory
        dir_path.mkdir(parents=True, exist_ok=True)
        print(f"   Created: {directory}")
    
    # Create __init__.py files
    init_files = [
        "backend/__init__.py",
        "backend/agents/__init__.py",
        "backend/agents/inventory_agent_a2a/__init__.py",
        "backend/agents/customer_service_a2a/__init__.py",
        "backend/host_agent/__init__.py",
        "backend/utils/__init__.py",
    ]
    
    for init_file in init_files:
        file_path = ROOT / init_file
        if not file_path.exists():
            file_path.touch()
            print(f"   Created: {init_file}")
    
    print("✅ Project structure ready")


def clean_project():
    """Clean up generated files."""
    print("🧹 Cleaning up project...")
    
    # Remove Python cache
    import shutil
    for cache_dir in ROOT.rglob("__pycache__"):
        shutil.rmtree(cache_dir, ignore_errors=True)
    
    for pyc_file in ROOT.rglob("*.pyc"):
        pyc_file.unlink(missing_ok=True)
    
    # Clean logs
    logs_dir = ROOT / "logs"
    if logs_dir.exists():
        for log_file in logs_dir.glob("*.log"):
            log_file.unlink(missing_ok=True)
    
    print("✅ Project cleaned")


def test_setup():
    """Test the setup."""
    print("🧪 Testing setup...")
    
    # Run the test script
    test_script = ROOT / "scripts" / "test_a2a_setup.py"
    if test_script.exists():
        try:
            result = subprocess.run([
                sys.executable, str(test_script)
            ], capture_output=True, text=True, cwd=ROOT)
            
            if result.returncode == 0:
                print("✅ Setup test passed")
                return True
            else:
                print("❌ Setup test failed")
                print(result.stdout)
                print(result.stderr)
                return False
        except Exception as e:
            print(f"❌ Test execution failed: {e}")
            return False
    else:
        print("⚠️  Test script not found")
        return False


def main():
    """Main entry point for dev utilities."""
    import argparse
    
    parser = argparse.ArgumentParser(description="A2A Retail Demo Development Utilities")
    parser.add_argument("--check", action="store_true", help="Check system requirements")
    parser.add_argument("--setup", action="store_true", help="Set up project structure")
    parser.add_argument("--clean", action="store_true", help="Clean up generated files")
    parser.add_argument("--test", action="store_true", help="Test the setup")
    
    args = parser.parse_args()
    
    if args.check:
        print("🔍 Checking system requirements...")
        checks = [
            ("Python version", check_python_version),
            ("Virtual environment", check_virtual_environment),
            ("Environment file", check_environment_file),
            ("Dependencies", check_dependencies),
            ("Ports", check_ports),
        ]
        
        all_passed = True
        for name, check_func in checks:
            print(f"\n{name}:")
            if not check_func():
                all_passed = False
        
        if all_passed:
            print("\n🎉 All checks passed!")
        else:
            print("\n❌ Some checks failed. Please fix the issues above.")
            sys.exit(1)
    
    elif args.setup:
        setup_project()
    
    elif args.clean:
        clean_project()
    
    elif args.test:
        if not test_setup():
            sys.exit(1)
    
    else:
        parser.print_help()


if __name__ == "__main__":
    main()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/test_agents.py ===
#!/usr/bin/env python3
"""Test script to verify all A2A agents are working correctly."""

import asyncio
import json
import sys
from pathlib import Path

# Add project root to path
ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(ROOT))

import httpx
from a2a.client import A2AClient
from a2a.types import (
    Message,
    Part,
    Role,
    TextPart,
    SendMessageRequest,
    MessageSendParams,
)


async def test_agent(name: str, url: str, test_query: str):
    """Test a single agent."""
    print(f"\n🧪 Testing {name} at {url}")
    print(f"   Query: {test_query}")
    
    try:
        async with httpx.AsyncClient() as hc:
            # Get agent card
            print("   📋 Fetching agent card...")
            client = await A2AClient.get_client_from_agent_card_url(
                httpx_client=hc,
                base_url=url
            )
            
            if hasattr(client, 'agent_card') and client.agent_card:
                print(f"   ✅ Agent: {client.agent_card.name}")
                print(f"   📝 Description: {client.agent_card.description}")
            
            # Send test message
            print("   📤 Sending test message...")
            message = Message(
                messageId="test-001",
                role=Role.user,
                parts=[Part(root=TextPart(text=test_query))]
            )
            
            request = SendMessageRequest(
                params=MessageSendParams(message=message)
            )
            response = await client.send_message(request)
            
            # Extract response
            print("   📥 Response received:")
            if hasattr(response, 'root'):
                result = response.root.result
            else:
                result = response.result if hasattr(response, 'result') else response
            
            # Try to extract text
            response_text = None
            if hasattr(result, 'artifacts') and result.artifacts:
                for artifact in result.artifacts:
                    if artifact.parts:
                        for part in artifact.parts:
                            if hasattr(part, 'root') and hasattr(part.root, 'text'):
                                response_text = part.root.text
                                break
            elif hasattr(result, 'parts') and result.parts:
                for part in result.parts:
                    if hasattr(part, 'root') and hasattr(part.root, 'text'):
                        response_text = part.root.text
                        break
            elif hasattr(result, 'status') and hasattr(result.status, 'message'):
                if result.status.message and hasattr(result.status.message, 'parts'):
                    for part in result.status.message.parts:
                        if hasattr(part, 'root') and hasattr(part.root, 'text'):
                            response_text = part.root.text
                            break
            
            if response_text:
                print(f"   💬 Response: {response_text[:200]}...")
                print("   ✅ Agent test passed!")
            else:
                print(f"   ⚠️  No text response extracted")
                print(f"   📊 Response structure: {type(result)}")
                
    except Exception as e:
        print(f"   ❌ Error: {type(e).__name__}: {str(e)}")
        return False
    
    return True


async def test_direct_api_call(name: str, url: str, query: str):
    """Test agent using direct JSON-RPC API call."""
    print(f"\n🔧 Testing {name} via direct API call")
    
    try:
        async with httpx.AsyncClient() as client:
            payload = {
                "jsonrpc": "2.0",
                "method": "message/send",
                "params": {
                    "message": {
                        "role": "user",
                        "parts": [{
                            "type": "text",
                            "text": query
                        }]
                    }
                },
                "id": 1
            }
            
            response = await client.post(url, json=payload)
            response.raise_for_status()
            
            result = response.json()
            print(f"   📥 Raw response: {json.dumps(result, indent=2)[:500]}...")
            
            if "result" in result:
                print("   ✅ Direct API test passed!")
                return True
            elif "error" in result:
                print(f"   ❌ API Error: {result['error']}")
                return False
                
    except Exception as e:
        print(f"   ❌ Error: {type(e).__name__}: {str(e)}")
        return False


async def main():
    """Run all tests."""
    print("🧪 A2A Retail Demo - Agent Test Suite")
    print("=" * 60)
    
    agents = [
        ("Inventory Agent", "http://localhost:8001", "Do you have Smart TVs in stock?"),
        ("Customer Service Agent", "http://localhost:8002", "What are your store hours?"),
        ("Host Agent", "http://localhost:8000", "What's the status of order ORD-12345?"),
    ]
    
    # First, check if agents are accessible
    print("\n🔍 Checking agent availability...")
    available_agents = []
    
    async with httpx.AsyncClient() as client:
        for name, url, _ in agents:
            try:
                resp = await client.get(f"{url}/.well-known/agent.json", timeout=5)
                if resp.status_code == 200:
                    print(f"   ✅ {name}: Online")
                    available_agents.append((name, url, _))
                else:
                    print(f"   ❌ {name}: HTTP {resp.status_code}")
            except Exception as e:
                print(f"   ❌ {name}: {type(e).__name__}")
    
    if not available_agents:
        print("\n❌ No agents are available. Please start the agents first.")
        print("   Run: ./scripts/start_a2a_demo.sh")
        sys.exit(1)
    
    # Test each available agent
    print(f"\n📊 Testing {len(available_agents)} available agents...")
    
    passed = 0
    failed = 0
    
    for name, url, query in available_agents:
        # Test using A2A client
        if await test_agent(name, url, query):
            passed += 1
        else:
            failed += 1
            
            # If A2A client fails, try direct API
            print(f"\n   🔄 Retrying with direct API call...")
            if await test_direct_api_call(name, url, query):
                print("   ℹ️  Direct API works but A2A client failed")
    
    # Summary
    print("\n" + "=" * 60)
    print("📊 Test Summary:")
    print(f"   ✅ Passed: {passed}")
    print(f"   ❌ Failed: {failed}")
    print(f"   📈 Success Rate: {(passed/(passed+failed)*100):.1f}%")
    
    if failed > 0:
        print("\n💡 Troubleshooting tips:")
        print("   1. Check agent logs in ./logs/")
        print("   2. Ensure GOOGLE_API_KEY is set in .env")
        print("   3. Verify all dependencies are installed")
        print("   4. Try testing agents individually")
        sys.exit(1)
    else:
        print("\n🎉 All tests passed!")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n👋 Test interrupted")
    except Exception as e:
        print(f"\n❌ Test suite error: {e}")
        sys.exit(1)

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/utils/debug_imports.py ===
#!/usr/bin/env python3
"""Debug script to test all imports and components."""

import sys
import os
from pathlib import Path

# Add project root to Python path
ROOT = Path(__file__).resolve().parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

print(f"🔍 Debug Information")
print(f"📁 Working directory: {os.getcwd()}")
print(f"📁 Script location: {ROOT}")
print(f"🐍 Python version: {sys.version}")
print(f"🐍 Python path (first 3): {sys.path[:3]}")
print()

# Test imports one by one
print("🧪 Testing imports...")

try:
    import mesop as me
    print("✅ mesop imported successfully")
except ImportError as e:
    print(f"❌ Failed to import mesop: {e}")
    sys.exit(1)

try:
    import structlog
    print("✅ structlog imported successfully")
except ImportError as e:
    print(f"❌ Failed to import structlog: {e}")

try:
    from backend.config import settings
    print("✅ backend.config imported successfully")
    print(f"   📊 Settings available: {type(settings)}")
except ImportError as e:
    print(f"❌ Failed to import backend.config: {e}")
    print("   Check if backend/config/settings.py exists")

try:
    from backend.a2a import A2AClient
    print("✅ backend.a2a imported successfully")
except ImportError as e:
    print(f"❌ Failed to import backend.a2a: {e}")
    print("   Check if backend/a2a/__init__.py exists")

try:
    from frontend.components import agent_status
    print("✅ frontend.components imported successfully")
except ImportError as e:
    print(f"❌ Failed to import frontend.components: {e}")
    print("   Check if frontend/components/__init__.py exists")

print()
print("🧪 Testing Mesop functionality...")

try:
    @me.page(path="/debug", title="Debug Page")
    def debug_page():
        me.text("Debug page works!")
    
    print("✅ Mesop page decorator works")
except Exception as e:
    print(f"❌ Mesop page decorator failed: {e}")

try:
    wsgi_app = me.create_wsgi_app()
    print("✅ Mesop WSGI app creation works")
except Exception as e:
    print(f"❌ Mesop WSGI app creation failed: {e}")

print()
print("🎉 Import debugging completed!")

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/utils/simple_frontend.py ===
#!/usr/bin/env python3
"""Simple Mesop frontend to test basic functionality."""

import sys
from pathlib import Path

# Add project root to Python path
ROOT = Path(__file__).resolve().parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import mesop as me
from dataclasses import dataclass, field
from typing import List

@me.stateclass
class SimpleState:
    """Simple application state."""
    messages: List[str] = field(default_factory=list)
    current_input: str = ""
    agent_status: str = "Unknown"


@me.page(path="/", title="A2A Retail Demo - Simple")
def simple_page():
    """Simple test page."""
    state = me.state(SimpleState)
    
    with me.box(style=me.Style(padding=me.Padding.all(20))):
        me.text("🛍️ A2A Retail Demo", type="headline-4")
        me.text("Simple test interface", type="body-1", style=me.Style(color="gray", margin=me.Margin(bottom=20)))
        
        # Simple status
        with me.box(style=me.Style(background="#f5f5f5", padding=me.Padding.all(15), border_radius=8, margin=me.Margin(bottom=20))):
            me.text("Agent Status", type="subtitle-1")
            me.text(f"Status: {state.agent_status}")
            me.button("Check Status", on_click=check_status, type="stroked")
        
        # Simple chat
        with me.box(style=me.Style(border=me.Border.all(me.BorderSide(width=1, color="#e0e0e0")), padding=me.Padding.all(20), margin=me.Margin(bottom=20))):
            me.text("Messages:", type="subtitle-1")
            
            if state.messages:
                for msg in state.messages:
                    me.text(f"• {msg}")
            else:
                me.text("No messages yet", style=me.Style(color="gray"))
            
            # Input
            with me.box(style=me.Style(display="flex", gap=10, margin=me.Margin(top=20))):
                me.input(
                    label="Your message",
                    value=state.current_input,
                    on_input=on_input_change,
                    style=me.Style(flex_grow=1)
                )
                me.button("Send", on_click=send_message, type="raised")


def check_status(e: me.ClickEvent):
    """Check agent status."""
    state = me.state(SimpleState)
    
    try:
        import requests
        
        # Test inventory agent
        try:
            response = requests.get("http://localhost:8001/health", timeout=5)
            inventory_status = "Online" if response.status_code == 200 else "Offline"
        except:
            inventory_status = "Offline"
        
        # Test customer service agent
        try:
            response = requests.get("http://localhost:8002/health", timeout=5)
            customer_status = "Online" if response.status_code == 200 else "Offline"
        except:
            customer_status = "Offline"
        
        state.agent_status = f"Inventory: {inventory_status}, Customer Service: {customer_status}"
    except Exception as ex:
        state.agent_status = f"Error: {ex}"


def on_input_change(e: me.InputEvent):
    """Handle input change."""
    me.state(SimpleState).current_input = e.value


def send_message(e: me.ClickEvent):
    """Send a simple message."""
    state = me.state(SimpleState)
    
    if not state.current_input.strip():
        return
    
    # Add user message
    state.messages.append(f"You: {state.current_input}")
    
    # Simple echo response
    state.messages.append(f"Agent: I received your message: '{state.current_input}'")
    
    # Clear input
    state.current_input = ""


if __name__ == "__main__":
    import os
    
    HOST = os.environ.get("MESOP_HOST", "127.0.0.1")
    PORT = int(os.environ.get("MESOP_PORT", "8000"))
    
    print(f"🚀 Starting Simple Mesop UI on http://{HOST}:{PORT}")
    
    try:
        from werkzeug.serving import run_simple
        wsgi_app = me.create_wsgi_app()
        run_simple(HOST, PORT, wsgi_app, use_reloader=False, use_debugger=True)
    except Exception as e:
        print(f"❌ Failed to start: {e}")
        import traceback
        traceback.print_exc()

=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/scripts/utils/README.md ===
# Utility Scripts

This directory contains utility and debugging scripts for the A2A Retail Demo project.

## Scripts

- **dump_project.py**: Dumps all project files into a single text file for analysis
- **debug_imports.py**: Tests all imports and helps debug import issues
- **simple_frontend.py**: A simplified frontend for testing basic Mesop functionality

## Usage

```bash
# Dump project structure
python scripts/utils/dump_project.py

# Debug imports
python scripts/utils/debug_imports.py

# Run simple frontend for testing
python scripts/utils/simple_frontend.py
```


=== /Users/abdulzedan/Documents/PersonalProjects/a2a-retail-demo/.github/workflows/python.yaml ===
name: Python CI

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: backend
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Set up Python 3
        uses: actions/setup-python@v3
        with:
          python-version: "3.11"
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
          pip install -e .
      
      - name: Lint with Ruff (matching pre-commit)
        run: |
          ruff check . \
            --config ../pyproject.toml
      
      - name: Check formatting with Black
        run: black --check --verbose --config ../pyproject.toml .
      
      - name: Run unit tests
        run: pytest

